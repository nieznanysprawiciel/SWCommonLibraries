<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Sleeping Wombat Common Library: sw::SerializationCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Sleeping Wombat Common Library
   &#160;<span id="projectnumber">0.50.0</span>
   </div>
   <div id="projectbrief">swCommonLibrary</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sw</b></li><li class="navelem"><a class="el" href="classsw_1_1_serialization_core.html">SerializationCore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classsw_1_1_serialization_core-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sw::SerializationCore Class Reference<div class="ingroups"><a class="el" href="group___common_library.html">Common Library</a> &raquo; <a class="el" href="group___serialization.html">Serialization</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Core serialization/deserialization functions.  
 <a href="classsw_1_1_serialization_core.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_serialization_core_8h_source.html">SerializationCore.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7a0e45d0e7cb93c9a1ea7d1d30f6d625"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7a0e45d0e7cb93c9a1ea7d1d30f6d625"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a7a0e45d0e7cb93c9a1ea7d1d30f6d625">SerializeProperty</a> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="memdesc:a7a0e45d0e7cb93c9a1ea7d1d30f6d625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for classes derived from <a class="el" href="classsw_1_1_engine_object.html">EngineObject</a>.  <a href="#a7a0e45d0e7cb93c9a1ea7d1d30f6d625">More...</a><br /></td></tr>
<tr class="separator:a7a0e45d0e7cb93c9a1ea7d1d30f6d625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0e45d0e7cb93c9a1ea7d1d30f6d625"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7a0e45d0e7cb93c9a1ea7d1d30f6d625"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a7a0e45d0e7cb93c9a1ea7d1d30f6d625">SerializeProperty</a> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="memdesc:a7a0e45d0e7cb93c9a1ea7d1d30f6d625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for all not polymorphic objects.  <a href="#a7a0e45d0e7cb93c9a1ea7d1d30f6d625">More...</a><br /></td></tr>
<tr class="separator:a7a0e45d0e7cb93c9a1ea7d1d30f6d625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6242bb4680300786aa6019a86f5667"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a6242bb4680300786aa6019a86f5667"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4a6242bb4680300786aa6019a86f5667"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a4a6242bb4680300786aa6019a86f5667">DeserializeProperty</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="memdesc:a4a6242bb4680300786aa6019a86f5667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for deserializing generic objects inheriting <a class="el" href="classsw_1_1_engine_object.html" title="Base class for serializable objects. ">EngineObject</a>. <br /></td></tr>
<tr class="separator:a4a6242bb4680300786aa6019a86f5667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6242bb4680300786aa6019a86f5667"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a6242bb4680300786aa6019a86f5667"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4a6242bb4680300786aa6019a86f5667"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a4a6242bb4680300786aa6019a86f5667">DeserializeProperty</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="memdesc:a4a6242bb4680300786aa6019a86f5667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for deserializing non generic structures.. <br /></td></tr>
<tr class="separator:a4a6242bb4680300786aa6019a86f5667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a01360bc3215dbb082f119cf568cc5d51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01360bc3215dbb082f119cf568cc5d51"></a>
static std::vector&lt; rttr::property &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTypeFilteredProperties</b> (rttr::type objType, <a class="el" href="structsw_1_1_serialization_context.html">SerializationContext</a> *context)</td></tr>
<tr class="separator:a01360bc3215dbb082f119cf568cc5d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d7b294f621eadef6a834565707b07e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4d7b294f621eadef6a834565707b07e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>ShouldSave</b> (const rttr::property &amp;prop, MetaDataType saveFlag)</td></tr>
<tr class="separator:aa4d7b294f621eadef6a834565707b07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497086bf0674797776a2b74cbda56861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a497086bf0674797776a2b74cbda56861"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a497086bf0674797776a2b74cbda56861">IsPolymorphicType</a> (TypeID type)</td></tr>
<tr class="memdesc:a497086bf0674797776a2b74cbda56861"><td class="mdescLeft">&#160;</td><td class="mdescRight">We support only polymorphic types derived from <a class="el" href="classsw_1_1_engine_object.html" title="Base class for serializable objects. ">EngineObject</a>. <br /></td></tr>
<tr class="separator:a497086bf0674797776a2b74cbda56861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa190ef172811eab954480e26d09128fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa190ef172811eab954480e26d09128fe"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultSerialize</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const <a class="el" href="classsw_1_1_engine_object.html">EngineObject</a> *object)</td></tr>
<tr class="separator:aa190ef172811eab954480e26d09128fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e8947368b8e7617a26679bc72377ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02e8947368b8e7617a26679bc72377ef"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultDeserialize</b> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, <a class="el" href="classsw_1_1_engine_object.html">EngineObject</a> *object)</td></tr>
<tr class="separator:a02e8947368b8e7617a26679bc72377ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0476de4b46f5f8606aa8485e2a3a5690"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0476de4b46f5f8606aa8485e2a3a5690"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultSerializeImpl</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const rttr::instance &amp;object, rttr::type dynamicType)</td></tr>
<tr class="separator:a0476de4b46f5f8606aa8485e2a3a5690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb627de2a19d6c5af01e45bc64b0ee2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb627de2a19d6c5af01e45bc64b0ee2e"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultDeserializeImpl</b> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::type dynamicType)</td></tr>
<tr class="separator:afb627de2a19d6c5af01e45bc64b0ee2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67591b7f07041608a9271893780b6073"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67591b7f07041608a9271893780b6073"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>SerializePolymorphic</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="separator:a67591b7f07041608a9271893780b6073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5b9a6a50779b51ea6be99de7994b99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c5b9a6a50779b51ea6be99de7994b99"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>SerializePropertiesVec</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const rttr::instance &amp;object, std::vector&lt; rttr::property &gt; &amp;properties)</td></tr>
<tr class="separator:a2c5b9a6a50779b51ea6be99de7994b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de70dc21794acfb62cf563de643a44f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a2de70dc21794acfb62cf563de643a44f">DeserializePolymorphic</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="separator:a2de70dc21794acfb62cf563de643a44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8745a6c6ad2d2ae0b303c7fc138dd8d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a8745a6c6ad2d2ae0b303c7fc138dd8d3">DeserializeNotPolymorphic</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="separator:a8745a6c6ad2d2ae0b303c7fc138dd8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab659878ab9fd8d469cb1b2bfa32250ef"><td class="memItemLeft" align="right" valign="top">static rttr::variant&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#ab659878ab9fd8d469cb1b2bfa32250ef">CreateAndSetObjectProperty</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::property &amp;prop, TypeID dynamicType)</td></tr>
<tr class="separator:ab659878ab9fd8d469cb1b2bfa32250ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb1d33b512caeb012d7925636b24937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeb1d33b512caeb012d7925636b24937"></a>
static rttr::variant&#160;</td><td class="memItemRight" valign="bottom"><b>CreateInstance</b> (TypeID type)</td></tr>
<tr class="separator:adeb1d33b512caeb012d7925636b24937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d6af59ddeb4a607fe98d36ff880964"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85d6af59ddeb4a607fe98d36ff880964"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>WstringToUTF</b> (const std::wstring &amp;str)</td></tr>
<tr class="separator:a85d6af59ddeb4a607fe98d36ff880964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c423c3af4b2d011961cd81358d4ee9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c423c3af4b2d011961cd81358d4ee9f"></a>
static std::wstring&#160;</td><td class="memItemRight" valign="bottom"><b>UTFToWstring</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a6c423c3af4b2d011961cd81358d4ee9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b73d4296e38f5ff1ab770cce63bda0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a35b73d4296e38f5ff1ab770cce63bda0"></a>
template&lt;typename PropertyType &gt; </td></tr>
<tr class="memitem:a35b73d4296e38f5ff1ab770cce63bda0"><td class="memTemplItemLeft" align="right" valign="top">static PropertyType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a35b73d4296e38f5ff1ab770cce63bda0">GetPropertyValue</a> (rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="memdesc:a35b73d4296e38f5ff1ab770cce63bda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns typed property value. <br /></td></tr>
<tr class="separator:a35b73d4296e38f5ff1ab770cce63bda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d0e40cc02559de16c20d25ec3b3f01"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType &gt; </td></tr>
<tr class="memitem:a00d0e40cc02559de16c20d25ec3b3f01"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a00d0e40cc02559de16c20d25ec3b3f01">SerializeProperty</a> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="memdesc:a00d0e40cc02559de16c20d25ec3b3f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializuje właściwość podanego typu.  <a href="#a00d0e40cc02559de16c20d25ec3b3f01">More...</a><br /></td></tr>
<tr class="separator:a00d0e40cc02559de16c20d25ec3b3f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150a72dade8c7f6414acf15d6ffb68dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a150a72dade8c7f6414acf15d6ffb68dc"></a>
template&lt;typename PropertyType &gt; </td></tr>
<tr class="memitem:a150a72dade8c7f6414acf15d6ffb68dc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::string_view name, const rttr::variant &amp;propertyValue)</td></tr>
<tr class="separator:a150a72dade8c7f6414acf15d6ffb68dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb805c80193b5765dcbecaab2ddce175"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:adb805c80193b5765dcbecaab2ddce175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb805c80193b5765dcbecaab2ddce175"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:adb805c80193b5765dcbecaab2ddce175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb805c80193b5765dcbecaab2ddce175"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:adb805c80193b5765dcbecaab2ddce175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb805c80193b5765dcbecaab2ddce175"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:adb805c80193b5765dcbecaab2ddce175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb805c80193b5765dcbecaab2ddce175"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:adb805c80193b5765dcbecaab2ddce175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb805c80193b5765dcbecaab2ddce175"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:adb805c80193b5765dcbecaab2ddce175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e67833cac58bfcdfed188454acda993"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e67833cac58bfcdfed188454acda993"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4e67833cac58bfcdfed188454acda993"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:a4e67833cac58bfcdfed188454acda993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d155347ceb850927694d4cf92d44dc1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d155347ceb850927694d4cf92d44dc1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0d155347ceb850927694d4cf92d44dc1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::string_view name, const rttr::variant &amp;propertyValue)</td></tr>
<tr class="separator:a0d155347ceb850927694d4cf92d44dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a37f88e8d60932404f3c30a4753d59a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8a37f88e8d60932404f3c30a4753d59a"></a>
template&lt;typename PropertyType &gt; </td></tr>
<tr class="memitem:a8a37f88e8d60932404f3c30a4753d59a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a8a37f88e8d60932404f3c30a4753d59a">SetPropertyValue</a> (rttr::property prop, const rttr::instance &amp;object, PropertyType value)</td></tr>
<tr class="memdesc:a8a37f88e8d60932404f3c30a4753d59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ustawia wartość podanej właściwości. <br /></td></tr>
<tr class="separator:a8a37f88e8d60932404f3c30a4753d59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed272f7c8a32ceca7e6d11883a22619"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType &gt; </td></tr>
<tr class="memitem:a6ed272f7c8a32ceca7e6d11883a22619"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a6ed272f7c8a32ceca7e6d11883a22619">DeserializeProperty</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="memdesc:a6ed272f7c8a32ceca7e6d11883a22619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializuje właściwość podanego typu.  <a href="#a6ed272f7c8a32ceca7e6d11883a22619">More...</a><br /></td></tr>
<tr class="separator:a6ed272f7c8a32ceca7e6d11883a22619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="acefeb9607735b51aa5399f223979d8c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DeserializeProperty</b> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:acefeb9607735b51aa5399f223979d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="acefeb9607735b51aa5399f223979d8c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DeserializeProperty</b> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:acefeb9607735b51aa5399f223979d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="acefeb9607735b51aa5399f223979d8c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DeserializeProperty</b> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:acefeb9607735b51aa5399f223979d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="acefeb9607735b51aa5399f223979d8c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DeserializeProperty</b> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:acefeb9607735b51aa5399f223979d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="acefeb9607735b51aa5399f223979d8c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DeserializeProperty</b> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:acefeb9607735b51aa5399f223979d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="acefeb9607735b51aa5399f223979d8c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DeserializeProperty</b> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:acefeb9607735b51aa5399f223979d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaa5d812e271a72ae14e1cc3828f253"><td class="memTemplParams" colspan="2"><a class="anchor" id="abcaa5d812e271a72ae14e1cc3828f253"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abcaa5d812e271a72ae14e1cc3828f253"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DeserializeProperty</b> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:abcaa5d812e271a72ae14e1cc3828f253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4273c688c8c5dfed914ff718db5de2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe4273c688c8c5dfed914ff718db5de2"></a>
static TypeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#abe4273c688c8c5dfed914ff718db5de2">GetRealType</a> (const rttr::instance &amp;object)</td></tr>
<tr class="memdesc:abe4273c688c8c5dfed914ff718db5de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets real type of the object that means most derived and wrapped type. <br /></td></tr>
<tr class="separator:abe4273c688c8c5dfed914ff718db5de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31b9dbd41dd6cb09fa39aef0ba5c46a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac31b9dbd41dd6cb09fa39aef0ba5c46a"></a>
static TypeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#ac31b9dbd41dd6cb09fa39aef0ba5c46a">GetWrappedType</a> (TypeID type)</td></tr>
<tr class="memdesc:ac31b9dbd41dd6cb09fa39aef0ba5c46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets wrapped type. If type isn't wrapper it returns it unmodified. <br /></td></tr>
<tr class="separator:ac31b9dbd41dd6cb09fa39aef0ba5c46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf72a99b128b906d29475c591873d87c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf72a99b128b906d29475c591873d87c"></a>
static TypeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#abf72a99b128b906d29475c591873d87c">GetRawWrappedType</a> (TypeID type)</td></tr>
<tr class="memdesc:abf72a99b128b906d29475c591873d87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">First extracts wrapped type and then returns raw type. <br /></td></tr>
<tr class="separator:abf72a99b128b906d29475c591873d87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbeaba917a415118bb17e76e2c7bd18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fbeaba917a415118bb17e76e2c7bd18"></a>
static <a class="el" href="structsw_1_1_serialization_context.html">SerializationContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a0fbeaba917a415118bb17e76e2c7bd18">Context</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser)</td></tr>
<tr class="memdesc:a0fbeaba917a415118bb17e76e2c7bd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns SerialziationContext from deserializer. <br /></td></tr>
<tr class="separator:a0fbeaba917a415118bb17e76e2c7bd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166115f01cd217a4b6a400c78f7d4262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a166115f01cd217a4b6a400c78f7d4262"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a166115f01cd217a4b6a400c78f7d4262">DestroyObject</a> (rttr::variant &amp;object)</td></tr>
<tr class="memdesc:a166115f01cd217a4b6a400c78f7d4262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy object in variant. <br /></td></tr>
<tr class="separator:a166115f01cd217a4b6a400c78f7d4262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb805c80193b5765dcbecaab2ddce175"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb805c80193b5765dcbecaab2ddce175"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:adb805c80193b5765dcbecaab2ddce175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d155347ceb850927694d4cf92d44dc1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d155347ceb850927694d4cf92d44dc1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0d155347ceb850927694d4cf92d44dc1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SerializeProperty</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::string_view name, const rttr::variant &amp;propertyValue)</td></tr>
<tr class="separator:a0d155347ceb850927694d4cf92d44dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:acefeb9607735b51aa5399f223979d8c4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#acefeb9607735b51aa5399f223979d8c4">DeserializeProperty</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, rttr::property prop, const rttr::instance &amp;object)</td></tr>
<tr class="separator:acefeb9607735b51aa5399f223979d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Types serialization</div></td></tr>
<tr class="memitem:aee89ff077e8e573595f1f15b967cbc79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee89ff077e8e573595f1f15b967cbc79"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#aee89ff077e8e573595f1f15b967cbc79">SerializeBasicTypes</a> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="memdesc:aee89ff077e8e573595f1f15b967cbc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize basic arithemtic types and bool. <br /></td></tr>
<tr class="separator:aee89ff077e8e573595f1f15b967cbc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f8e901dfd336a6be4b629380f91633"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f8e901dfd336a6be4b629380f91633"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>SerializeVectorTypes</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="separator:a49f8e901dfd336a6be4b629380f91633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279555f99934729bd91b3f4d6c30797d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a279555f99934729bd91b3f4d6c30797d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>SerializeStringTypes</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="separator:a279555f99934729bd91b3f4d6c30797d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152905469d23076e1360bf9f10efc630"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a152905469d23076e1360bf9f10efc630">SerializeEnumTypes</a> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="separator:a152905469d23076e1360bf9f10efc630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310dbf3bd331048359152e5f1b3debcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a310dbf3bd331048359152e5f1b3debcf"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>SerializeArrayTypes</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="separator:a310dbf3bd331048359152e5f1b3debcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f3cc41a564d7b67b293da7947b7ae2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f3cc41a564d7b67b293da7947b7ae2"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>SerializeObjectTypes</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="separator:a41f3cc41a564d7b67b293da7947b7ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4aa8f3a5518b206d715a152fcadb13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f4aa8f3a5518b206d715a152fcadb13"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>SerializeBasicTypes</b> (<a class="el" href="class_i_serializer.html">ISerializer</a> &amp;ser, rttr::string_view name, const rttr::variant &amp;propertyValue)</td></tr>
<tr class="separator:a9f4aa8f3a5518b206d715a152fcadb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Types deserialization</div></td></tr>
<tr class="memitem:a2496c7f9670a987ed479f90ca782ff8c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a2496c7f9670a987ed479f90ca782ff8c">DeserializeBasicTypes</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="memdesc:a2496c7f9670a987ed479f90ca782ff8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize basic arithemtic types and bool.  <a href="#a2496c7f9670a987ed479f90ca782ff8c">More...</a><br /></td></tr>
<tr class="separator:a2496c7f9670a987ed479f90ca782ff8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7039b5fe5396632e8664e62893723e3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#aa7039b5fe5396632e8664e62893723e3">DeserializeVectorTypes</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="memdesc:aa7039b5fe5396632e8664e62893723e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializuje typy DirectXMath.  <a href="#aa7039b5fe5396632e8664e62893723e3">More...</a><br /></td></tr>
<tr class="separator:aa7039b5fe5396632e8664e62893723e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b9afd918fe1b7aa49eb6e4c5580de3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a53b9afd918fe1b7aa49eb6e4c5580de3">DeserializeStringTypes</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="memdesc:a53b9afd918fe1b7aa49eb6e4c5580de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializuje std::string i std::wstring.  <a href="#a53b9afd918fe1b7aa49eb6e4c5580de3">More...</a><br /></td></tr>
<tr class="separator:a53b9afd918fe1b7aa49eb6e4c5580de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a64062ef0c5193f6694187c5634f600"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a8a64062ef0c5193f6694187c5634f600">DeserializeEnumTypes</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="memdesc:a8a64062ef0c5193f6694187c5634f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes enum properties from string.  <a href="#a8a64062ef0c5193f6694187c5634f600">More...</a><br /></td></tr>
<tr class="separator:a8a64062ef0c5193f6694187c5634f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfc2a1eaadad7c17ab75a4dd88e640e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a2bfc2a1eaadad7c17ab75a4dd88e640e">DeserializeArrayTypes</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="memdesc:a2bfc2a1eaadad7c17ab75a4dd88e640e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes arrays.  <a href="#a2bfc2a1eaadad7c17ab75a4dd88e640e">More...</a><br /></td></tr>
<tr class="separator:a2bfc2a1eaadad7c17ab75a4dd88e640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f3c1fc88f343d0e1606e73a6c9fd52"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1_serialization_core.html#a51f3c1fc88f343d0e1606e73a6c9fd52">DeserializeObjectTypes</a> (const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;deser, const rttr::instance &amp;object, rttr::property &amp;prop)</td></tr>
<tr class="memdesc:a51f3c1fc88f343d0e1606e73a6c9fd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes structures and generic objects.  <a href="#a51f3c1fc88f343d0e1606e73a6c9fd52">More...</a><br /></td></tr>
<tr class="separator:a51f3c1fc88f343d0e1606e73a6c9fd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core serialization/deserialization functions. </p>
<p>This class is usefull only if you write your own serialization implementation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab659878ab9fd8d469cb1b2bfa32250ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rttr::variant sw::SerializationCore::CreateAndSetObjectProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeID&#160;</td>
          <td class="paramname"><em>dynamicType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>When created type is raw pointer and property is wrapped type, we could handle this case by creating wrapper from pointer. Consider this in future. Many problems could apear, when it comes to ownership of memory and so on. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>We must take into considerations other wrapper types which not necessary take ownership of object. To do this we must be able to determine wrapper template type and have some traits connected to ownership. Think about it in future. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bfc2a1eaadad7c17ab75a4dd88e640e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::SerializationCore::DeserializeArrayTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializes arrays. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when object have been deserialized. Otherwise you should try with functions deserializing other types. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Error handling. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>This warning should be conditional depending on flag in <a class="el" href="structsw_1_1_serialization_context.html" title="Serialization context for automatic serialization. ">SerializationContext</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2496c7f9670a987ed479f90ca782ff8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::SerializationCore::DeserializeBasicTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize basic arithemtic types and bool. </p>
<p>Deserializuje podstawowe typy.</p>
<p>Funkcja sprawdza typ własciwości i deserializuje go tylko jeżeli jest jednym z obsługiwanych przez nią typów. W przeciwnym razie nie robi nic.</p>
<dl class="section return"><dt>Returns</dt><dd>Funkcja zwraca true, jeżeli udało jej się obsłużyć podany typ. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a64062ef0c5193f6694187c5634f600"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::SerializationCore::DeserializeEnumTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializes enum properties from string. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when object have been deserialized. Otherwise you should try with functions deserializing other types. </dd></dl>
<p>Type haven't been registered. </p>

</div>
</div>
<a class="anchor" id="a8745a6c6ad2d2ae0b303c7fc138dd8d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::SerializationCore::DeserializeNotPolymorphic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>This warning should be conditional depending on flag in <a class="el" href="structsw_1_1_serialization_context.html" title="Serialization context for automatic serialization. ">SerializationContext</a>. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>This warning should be conditional depending on flag in <a class="el" href="structsw_1_1_serialization_context.html" title="Serialization context for automatic serialization. ">SerializationContext</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a51f3c1fc88f343d0e1606e73a6c9fd52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::SerializationCore::DeserializeObjectTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializes structures and generic objects. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when object have been deserialized. Otherwise you should try with functions deserializing other types. </dd></dl>

</div>
</div>
<a class="anchor" id="a2de70dc21794acfb62cf563de643a44f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::SerializationCore::DeserializePolymorphic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>This warning should be conditional depending on flag in <a class="el" href="structsw_1_1_serialization_context.html" title="Serialization context for automatic serialization. ">SerializationContext</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ed272f7c8a32ceca7e6d11883a22619"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::SerializationCore::DeserializeProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializuje właściwość podanego typu. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>Można zoptymalizować pobieranie nazwy z właściwości i ograniczyć alokację stringów. </dd></dl>

</div>
</div>
<a class="anchor" id="acefeb9607735b51aa5399f223979d8c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sw::SerializationCore::DeserializeProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>Error handling. </dd></dl>

</div>
</div>
<a class="anchor" id="a53b9afd918fe1b7aa49eb6e4c5580de3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::SerializationCore::DeserializeStringTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializuje std::string i std::wstring. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when object have been deserialized. Otherwise you should try with functions deserializing other types. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7039b5fe5396632e8664e62893723e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::SerializationCore::DeserializeVectorTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_deserializer.html">IDeserializer</a> &amp;&#160;</td>
          <td class="paramname"><em>deser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializuje typy DirectXMath. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when object have been deserialized. Otherwise you should try with functions deserializing other types. </dd></dl>

</div>
</div>
<a class="anchor" id="a152905469d23076e1360bf9f10efc630"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::SerializationCore::SerializeEnumTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_serializer.html">ISerializer</a> &amp;&#160;</td>
          <td class="paramname"><em>ser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type haven't been registered. </p>

</div>
</div>
<a class="anchor" id="a00d0e40cc02559de16c20d25ec3b3f01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::SerializationCore::SerializeProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_serializer.html">ISerializer</a> &amp;&#160;</td>
          <td class="paramname"><em>ser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializuje właściwość podanego typu. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Można zoptymalizować pobieranie nazwy z właściwości i ograniczyć alokację stringów. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a0e45d0e7cb93c9a1ea7d1d30f6d625"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sw::SerializationCore::SerializeProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_serializer.html">ISerializer</a> &amp;&#160;</td>
          <td class="paramname"><em>ser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template specialization for classes derived from <a class="el" href="classsw_1_1_engine_object.html">EngineObject</a>. </p>
<p>Function serializes property name as first. Then <a class="el" href="classsw_1_1_engine_object.html#aaba5beea5aede80d6dc77bcabee41445" title="Implements default serialization.  Serializes only declared properties. ">EngineObject::Serialize</a> method is invoked.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use SerializePolymorphic instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a0e45d0e7cb93c9a1ea7d1d30f6d625"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sw::SerializationCore::SerializeProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_serializer.html">ISerializer</a> &amp;&#160;</td>
          <td class="paramname"><em>ser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rttr::property&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rttr::instance &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization for all not polymorphic objects. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use DeserializeNotPolymorphic instead. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Serialization/PropertySerialization/Core/<a class="el" href="_serialization_core_8h_source.html">SerializationCore.h</a></li>
<li>Serialization/PropertySerialization/Core/SerializationCore.cpp</li>
<li>Serialization/PropertySerialization/Core/<a class="el" href="_serialization_core_8inl.html">SerializationCore.inl</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 31 2018 19:56:00 for Sleeping Wombat Common Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
